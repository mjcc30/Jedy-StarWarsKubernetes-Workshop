from fastapi import APIRouter, Depends, HTTPException, Response
from sqlmodel import Session, select
from pydantic import BaseModel
import base64
import requests

from ..ai_service import chat_with_character, generate_image_nano_banana, is_ai_enabled
from ..security import get_current_user
from ..database import engine
from ..models import EntityImage

router = APIRouter()


def get_session():
    with Session(engine) as session:
        yield session


class ChatRequest(BaseModel):
    character_name: str
    character_context: str
    message: str


@router.get("/status")
def get_ai_status():
    """Returns the status of the AI service."""
    return {"enabled": is_ai_enabled()}


@router.post("/chat")
async def chat(request: ChatRequest, current_user: str = Depends(get_current_user)):
    if not is_ai_enabled():
        raise HTTPException(
            status_code=503, detail="AI services are currently disabled."
        )

    response = await chat_with_character(
        request.character_name, request.character_context, request.message
    )
    return {"response": response}


@router.get("/image")
async def get_entity_image(
    name: str,
    type: str,
    force_refresh: bool = False,
    session: Session = Depends(get_session),
):
    if not is_ai_enabled():
        # If disabled, we do not generate or fetch images.
        # Returns 503 so frontend shows placeholder.
        raise HTTPException(
            status_code=503, detail="AI services are currently disabled."
        )

    # 1. Check Database (unless forcing refresh)
    if not force_refresh:
        db_image = session.exec(
            select(EntityImage).where(EntityImage.entity_name == name)
        ).first()

        if db_image:
            # If stored as URL (pollinations fallback)
            if db_image.image_url.startswith("http"):
                return Response(
                    content=requests.get(db_image.image_url).content,
                    media_type="image/png",
                )
            # If stored as base64 (Gemini)
            return Response(
                content=base64.b64decode(db_image.image_url), media_type="image/png"
            )

    # 2. Generate with Nano Banana (Gemini 2.5 Flash Image)
    # Note: Since we don't have a guaranteed live Nano Banana endpoint in this simulated environment
    # we will fallback gracefully to Pollinations if Nano Banana returns None,
    # BUT we structure it to use Nano Banana primarily.

    image_data = await generate_image_nano_banana(name, type)

    if image_data:
        # Success with Nano Banana
        b64_str = base64.b64encode(image_data).decode("utf-8")

        # Update or Create
        existing_img = session.exec(
            select(EntityImage).where(EntityImage.entity_name == name)
        ).first()
        if existing_img:
            existing_img.image_url = b64_str
            existing_img.description = "Regenerated by Gemini 2.5"
            session.add(existing_img)
        else:
            new_image = EntityImage(
                entity_name=name,
                image_url=b64_str,
                description="Generated by Gemini 2.5",
            )
            session.add(new_image)

        session.commit()
        return Response(content=image_data, media_type="image/png")

    # 3. Fallback to Pollinations (if Gemini fails or quota exceeded)
    # We use Pollinations URL as the "source". We add a random seed if refreshing to get a new image.
    import random

    seed = random.randint(0, 10000) if force_refresh else len(name)
    fallback_url = f"https://pollinations.ai/p/{name} star wars cinematic?width=400&height=225&nologo=true&seed={seed}"

    # Update or Create
    existing_img = session.exec(
        select(EntityImage).where(EntityImage.entity_name == name)
    ).first()
    if existing_img:
        existing_img.image_url = fallback_url
        existing_img.description = "Regenerated Pollinations Fallback"
        session.add(existing_img)
    else:
        new_image = EntityImage(
            entity_name=name,
            image_url=fallback_url,
            description="Pollinations Fallback",
        )
        session.add(new_image)

    session.commit()

    # Fetch and return the image bytes
    try:
        r = requests.get(fallback_url)
        return Response(content=r.content, media_type="image/jpeg")
    except:
        raise HTTPException(status_code=404, detail="Image generation failed")
